<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="renderer" content="webkit"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.0-rc.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.0-rc.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta property="og:title">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Samson Yuen">
<meta name="twitter:card" content="summary"><meta name="keywords" content="Samson Yuen, null"><meta name="description" content=""><title>null</title><link ref="canonical" href="http://yoursite.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0-rc.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: true,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-child"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title"></div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/04/28/1-2-%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AE%83%E4%BB%AC%E6%89%80%E4%BA%A7%E7%94%9F%E7%9A%84%E8%AE%A1%E7%AE%97/">1.2 过程与它们所产生的计算</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-04-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-04-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <!-- hexo-inject:begin --><!-- hexo-inject:end --><h3 id="原文摘录"   >
          <a href="#原文摘录" class="heading-link"><i class="fas fa-link"></i></a>原文摘录</h3>
      <p>在这一节里，我们将考察由一些简单过程所产生的计算过程的“形状”，还将研究这些计算过程消耗各种重要计算资源（时间和空间）的速率。</p>

        <h3 id="1-2-1-线性的递归和迭代"   >
          <a href="#1-2-1-线性的递归和迭代" class="heading-link"><i class="fas fa-link"></i></a>1.2.1 线性的递归和迭代</h3>
      
        <h3 id="本节概要"   >
          <a href="#本节概要" class="heading-link"><i class="fas fa-link"></i></a>本节概要</h3>
      <p>本节以求n!为例讲述线性递归计算模型与线性迭代计算模型的概念及其区别。</p>
<p>线性递归计算模型求阶乘：</p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">*</span></span> n (<span class="name">factorial</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>线性迭代模型求阶乘</p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factorial-iter</span> n product counter)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> counter n)</span><br><span class="line">            product</span><br><span class="line">            (<span class="name">factorial-iter</span> n (<span class="name"><span class="builtin-name">*</span></span> product counter) (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> counter))    </span><br><span class="line">        )</span><br><span class="line">    )   </span><br><span class="line">    (<span class="name">factorial-iter</span> n <span class="number">1</span> <span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>现在对两个计算过程做一个比较。</p>
<p><strong>（一新按：原作者对这两个计算过程的比较的描述已然完美，珠玉在前，笔者不再自行阐述，以下仅摘录原文作为注释）</strong></p>
<p>考虑第一个计算过程。代换模型揭示出一种先逐步展开而后收缩的形状，……在展开阶段里，这一计算过程构造起一个推迟进行的操作所形成的链条……收缩阶段表现为这些运算的实际执行。这种类型的计算过程由一个推迟执行的运算链条刻画，称为一个递归计算过程。要执行这种计算过程，解释器就需要维护好那些以后将要执行的操作的轨迹。在计算阶乘n！时，推迟执行的乘法链条的长度也就是为保存<br>其轨迹需要保存的信息量，这个长度随着n值而线性增长（正比于n），就像计算中的步骤数目样。这样的计算过程称为一个线性递归过程。</p>
<p>与之相对应，第二个计算过程里并没有任何增长或者收缩。对于任何一个n，在计算过程中的每一步，在我们需要保存轨迹里，所有的东西就是变量 product、 counter和max-count的当前值。我们称这种过程为一个迭代计算过程。一般来说，迭代计算过程就是那种其状态可以用固定数目的状态变量蚤描述的计算过程;而与此同时，又存在着一套固定的规则描述了计算过程在从一个状态到下一状态转换时，这些变量的更新方式;还有一个（可能有的）结束检测，它描述这一计算过程应该终止的条件。在计算n！时，所需的计算步骤随着n线性增长，这种过程称为线性迭代过程。</p>
<p>……在迭代的情况里，在计算过程中的任何一点，那几个程序变量都提供了有关计算状态的一个完整描述。……<br>而对于递归计算过程而言，这里还存在着另外的一些“隐含”信息，它们并未保存在程字变量里，而是由解释器维持着，指明了在所推迟的运算所形成的链条里的漫游中，“这一计<br>算过程处在何处“。这个链条越长，需要保存的信息也就越多。</p>
<p>在做迭代与递归之间的比较时，我们必须当心，不要搞混了递归计算过程概念和递归过程的概念。当我们说一个过程是递归的时候，论述的是一个语法形式上的事实，说明这个<br>过程的定义中（直接或者间接地）引用了该过程本身。在说某一计算过程具有某种模式时（例如，线性递归），我们说的是这一计算过程的进展方式，而不是相应过程书写上的语法形式。当我们说某个递归过程（例如 fact-iter）将产生出一个迭代的计算过程时，可能会使人感到不舒服。然而这一计算过程确实是迭代的，因为它的状态能由其中的三个状态变量完全刻画，解释器在执行这一计算过程时，只需要保持这三个变量的轨迹就足够了。</p>

        <h3 id="练习"   >
          <a href="#练习" class="heading-link"><i class="fas fa-link"></i></a>练习</h3>
      <p> <strong> 练习1.9</strong></p>
<p> 第一个是线性递归的计算过程，因为前面有个inc，第二个是迭代的计算过程，因为a与b两个变量就可以完全描述当前的计算状态。</p>
<p><strong>1.10</strong></p>
<p>略</p>

        <h3 id="1-2-2-树形递归"   >
          <a href="#1-2-2-树形递归" class="heading-link"><i class="fas fa-link"></i></a>1.2.2 树形递归</h3>
      
        <h3 id="本节概要-1"   >
          <a href="#本节概要-1" class="heading-link"><i class="fas fa-link"></i></a>本节概要</h3>
      <p>实现斐波那契数列的两种算法：</p>
<ul>
<li>指数递归</li>
<li>线性迭代</li>
</ul>
<p>指数递归</p>
<ul>
<li>时间复杂度：指数级别</li>
<li>空间复杂度：$\Theta(n)$ (树形递归其空间需求正比于树的最大深度)</li>
</ul>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">Fib</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">          ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>) <span class="number">1</span>)</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span> (<span class="name"><span class="builtin-name">+</span></span>(<span class="name">Fib</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))</span><br><span class="line">                (<span class="name">Fib</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">2</span>)))</span><br><span class="line">          )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>线性迭代</p>
<ul>
<li>时间复杂度: $\Theta(n)$</li>
<li>空间复杂度：$\Theta(1)$</li>
</ul>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">Fib</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">Fib-iter</span> n counter a b)</span><br><span class="line">        (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> n counter) a)</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">Fib-iter</span> n (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> counter) b (<span class="name"><span class="builtin-name">+</span></span> a b)))</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    )</span><br><span class="line">    (<span class="name">Fib-iter</span> n <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p><strong>实例：换零钱方式的统计</strong><br>略</p>

        <h3 id="练习-1"   >
          <a href="#练习-1" class="heading-link"><i class="fas fa-link"></i></a>练习</h3>
      <p><strong>练习1.11</strong></p>
<p>递归过程<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&lt;</span></span> n <span class="number">3</span>) n)</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">f</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))</span><br><span class="line">                   (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> (<span class="name">f</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">2</span>)))</span><br><span class="line">                   (<span class="name"><span class="builtin-name">*</span></span> <span class="number">3</span> (<span class="name">f</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">3</span>)))</span><br><span class="line">                )</span><br><span class="line">          )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br>迭代过程</p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f-iter</span> n counter a b c)</span><br><span class="line">        (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> n counter) a)</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">f-iter</span> n (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> counter) b c (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">3</span> a) (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> b) c)))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    (<span class="name">f-iter</span> n <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p><strong>练习1.12</strong></p>
<p><strong>练习1.13</strong></p>
<p>与编程无关，是纯粹的数学问题，略</p>

        <h3 id="1-2-3-增长的阶"   >
          <a href="#1-2-3-增长的阶" class="heading-link"><i class="fas fa-link"></i></a>1.2.3 增长的阶</h3>
      
        <h3 id="原文摘录-1"   >
          <a href="#原文摘录-1" class="heading-link"><i class="fas fa-link"></i></a>原文摘录</h3>
      <p>……（对于同一个计算需求）不同的计算过程在消耗计算资源的速率上可能存在着巨大差异。</p>
<p>令n是一个参数，它能作为问题规模的一种度量，令R(n)是一个计算过程在处理规模为n的问题时所需要的资源量。</p>
<p>……一般而言，总存在着某个有关问题特性的数值，使我们可以相对于它去分析给定的计算过程。与此类似，R(n)<br>也可以是所用的内部寄存器数目的度量值，也可能是需要执行的机器操作数目的度量值，或者其他类似东西。<strong>在每个时刻只能执行固定数目的操作的计算机里，所需的时间将正比于需要执行的基本机器指令条数</strong>。</p>
<p>……我们称R(n)具有Θ(f(n))的增长阶，记为R(n)=Θ(f(n))（读做f(n)的”theta”），如果存在与n无关的整数k1和k2，使得 </p>
<center>**k1*f(n)≤R(n)≤k2*f(n)**</center>

<p> 对任何足够大的n值都成立（换们话说，对足够大的n，值R(n)总位于k1<em>f(n)和k2</em>f(n)之间）。</p>
<p>增长的阶为我们提供了对计算过程行为的一种很粗略的描述。例如，某廿算过程需要n^2步另一计算过程需要1000n^2步，还有一个计算过程需要3n^2+10n+17步，它们增长的阶都是Θ(n^2)。但在另一方面，增长的阶也为我们在问题规模改变时，预期一个计算过程的行为变化提供了有用的线索。</p>

        <h3 id="注释"   >
          <a href="#注释" class="heading-link"><i class="fas fa-link"></i></a>注释</h3>
      <p>算法分析的目的就是衡量算法的性能。我们总能在所需要处理的问题中找到一个可以衡量问题规模大小的参数，记作n。也总可以找到在输入规模为n时，该算法所占用的资源量，记作R(n)。那么，<strong>建立起一个n到R(n)的映射，就等于完成了对于任意输入的所对应的消耗的一般性描述，这就是算法分析的本质。</strong></p>
<p>有时候，n到R(n)的映射是充分复杂的，为了能够更加简便的进行分析，我们就定义了Θ记号，<strong>Θ记号法的本质在于找到一个函数f(n),使得当n充分大时，f(n)和真实的算法消耗R(n)在数量上是线性齐次的。这也就是说：f(n)和R(n)的数量级是同等的。于是f(n)可以代替R(n)来描述某算法在输入规模为n时的资源消耗量。</strong> 因此，简单说来，Θ记号法舍去了无关乎紧要的细枝末节（低次项）只<strong>找同阶的最简函数。</strong></p>
<p>另外，诚如作者所说，确实有很多因素可以作为我们去度量R(n)的标准。但一般的算法分析，我们往往只取其两个方面,即</p>
<ul>
<li><strong>算法的时间复杂度</strong></li>
<li><strong>算法的空间复杂度</strong></li>
</ul>
<p>时间复杂度就是指，概算法从开始运行到运行结束，一共消耗了多少个标准步骤，或者说一共执行了多少条基本机器指令条数。</p>
<p>但是在这里需要注意：任何的算法分析都是<strong>不精准</strong>的，因为我们首先已经假设了每一条基本机器指令的执行时间都是相同的。但这是不可能的，+与<em>显然耗时不同，函数调用和循环迭代也显然不同。更何况还使用了Θ记号，舍去了一切的系数和低次项。因此，<em>*算法分析的作用仅仅只是提供某个算法在消耗资源时的增长趋势</em></em>，而非精确描述该算法在n输入时究竟耗时多少。</p>
<p>时间复杂度则是指算法在运行时在内存中最多的时候占用了多少的空间。</p>

        <h3 id="练习-2"   >
          <a href="#练习-2" class="heading-link"><i class="fas fa-link"></i></a>练习</h3>
      <p><strong>1.14</strong></p>
<p>略 </p>
<p><strong>1.15</strong></p>
<ul>
<li>a. 5次</li>
<li>b. 时间和空间复杂度都是log(n)</li>
</ul>

        <h3 id="1-2-4-求幂"   >
          <a href="#1-2-4-求幂" class="heading-link"><i class="fas fa-link"></i></a>1.2.4 求幂</h3>
      
        <h3 id="本节概要-2"   >
          <a href="#本节概要-2" class="heading-link"><i class="fas fa-link"></i></a>本节概要</h3>
      <p>求一个数b的n次方可以有三种计算模型或算法：</p>
<ul>
<li>线性递归模型</li>
<li>线性迭代模型</li>
<li>连续求平方模型</li>
</ul>
<p>线性递归模型<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">expt</span></span> b n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>)</span><br><span class="line">        b</span><br><span class="line">        (<span class="name"><span class="builtin-name">*</span></span> b (<span class="name"><span class="builtin-name">expt</span></span> b (<span class="name"><span class="builtin-name">-</span></span> <span class="number">1</span> n)))</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br>线性迭代模型<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">expt</span></span> b n )</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">expt-iter</span> b n product counter)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> counter n)</span><br><span class="line">            product</span><br><span class="line">            (<span class="name">expt-iter</span> b n (<span class="name"><span class="builtin-name">*</span></span> b product) (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> counter))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    (<span class="name">expt-iter</span> b n <span class="number">1</span> <span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br>连续求平方模型</p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">expt</span></span> b n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> n) <span class="number">1</span>)</span><br><span class="line">          ((<span class="name"><span class="builtin-name">even?</span></span> n) (<span class="name">square</span> (<span class="name"><span class="builtin-name">expt</span></span> b (<span class="name"><span class="builtin-name">/</span></span> n <span class="number">2</span>))))</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span> (<span class="name"><span class="builtin-name">*</span></span> b (<span class="name"><span class="builtin-name">expt</span></span> b (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>连续求平方模型的精妙之处就在于，该算法将算法的空间复杂度和时间复杂度都降到了 $\Theta(\log n)$。另外，需要注意的是，even?是scheme内置的函数，可以直接使用，当然也可以手动实现：<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">even?</span></span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> (<span class="name"><span class="builtin-name">remainder</span></span> n <span class="number">2</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br>remainder也是scheme内置的过程，是一个求模运算符。</p>

        <h3 id="练习-3"   >
          <a href="#练习-3" class="heading-link"><i class="fas fa-link"></i></a>练习</h3>
      <p><strong>1.16</strong></p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">expt</span></span> x n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> a x n)</span><br><span class="line">        (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>) a)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">odd?</span></span> n) (<span class="name">iter</span> (<span class="name"><span class="builtin-name">*</span></span> a x) x (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">iter</span> a (<span class="name"><span class="builtin-name">*</span></span> x x) (<span class="name"><span class="builtin-name">/</span></span> n <span class="number">2</span>)))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    (<span class="name">iter</span> <span class="number">1</span> x n)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p><strong>1.17</strong><br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">*</span></span> a b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">double</span> x)</span><br><span class="line">        (<span class="name"><span class="builtin-name">+</span></span> x x)</span><br><span class="line">    )</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> b <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">          ((<span class="name"><span class="builtin-name">even?</span></span> b)(<span class="name">double</span> (<span class="name"><span class="builtin-name">*</span></span> a (<span class="name"><span class="builtin-name">/</span></span> b <span class="number">2</span>))))</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span> (<span class="name"><span class="builtin-name">+</span></span> a (<span class="name"><span class="builtin-name">*</span></span> a (<span class="name"><span class="builtin-name">-</span></span> b <span class="number">1</span>))))</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br><strong>1.18</strong><br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">double</span> a)(<span class="name"><span class="builtin-name">+</span></span> a a))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">*</span></span> a b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> product a b)</span><br><span class="line">        (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> b <span class="number">0</span>) product)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">odd?</span></span> b) (<span class="name">iter</span> (<span class="name"><span class="builtin-name">+</span></span> a product) a (<span class="name"><span class="builtin-name">-</span></span> b <span class="number">1</span>)))</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">iter</span> product (<span class="name">double</span> a) (<span class="name"><span class="builtin-name">/</span></span> b <span class="number">2</span>)))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    (<span class="name">iter</span> <span class="number">0</span> a b)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br><strong>1.19</strong></p>

        <h3 id="1-2-5-最大公约数"   >
          <a href="#1-2-5-最大公约数" class="heading-link"><i class="fas fa-link"></i></a>1.2.5 最大公约数</h3>
      
        <h3 id="本节概要-3"   >
          <a href="#本节概要-3" class="heading-link"><i class="fas fa-link"></i></a>本节概要</h3>
      <p>求两数的最大公约数可以利用欧几里得算法：<strong>如果r是a除以b的余数，那么a和b的公约数正好也是b的r的公约数</strong>。</p>
<p><center>GCD(a,b)=GCD(b,r)</center><br><br></p>
<p>GCD（206，40）=GCD（40，6）=GCD（6，4）=GCD（4，2）=GCD（2，0）=2</p>
<p>从任意两个正整数开始，<strong>反复执行这种归约，最终将产生出一个数对，其中的第二个数是0，此时的GCD就是另一个数</strong>。</p>
<p>欧几里得算法代码实现：</p>
<ul>
<li>时间复杂度：$\Theta(\log n)$</li>
<li>时间复杂度：$\Theta(1)$</li>
</ul>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">gcd</span></span> a b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> b <span class="number">0</span>)</span><br><span class="line">        a</span><br><span class="line">        (<span class="name"><span class="builtin-name">gcd</span></span> b (<span class="name"><span class="builtin-name">remainder</span></span> a b))</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>

        <h3 id="练习-4"   >
          <a href="#练习-4" class="heading-link"><i class="fas fa-link"></i></a>练习</h3>
      <p><strong>1.20</strong></p>
<p>应用序则进行5次remainder即可，因为每次gcd函数每次调用自身时会进行运算。</p>
<p>正则序则要运算很多次，因为每次gcd函数调用自身的时候都不会对remainder进行求值，而是等到所有递归出口的时候再统一进行运算。这样，“堆积”在最后一层调用的remainder就需要运算很多次。（具体多少次，时间有限，笔者实在懒于详细展开）</p>

        <h3 id="1-2-6-实例：素数检测"   >
          <a href="#1-2-6-实例：素数检测" class="heading-link"><i class="fas fa-link"></i></a>1.2.6 实例：素数检测</h3>
      
        <h3 id="本节概要-4"   >
          <a href="#本节概要-4" class="heading-link"><i class="fas fa-link"></i></a>本节概要</h3>
      <p>本节将描述两种检查整数n是否素数的方法：</p>
<ul>
<li>寻找因子法</li>
<li>费马检查法</li>
</ul>
<p>第一个具有的 $\Theta(\sqrt{n})$ 增长阶，而另一个“概率”算法具有$\Theta(\log n)$的增长阶。<strong>(一新按：这里的增长的阶指的都是时间复杂度)</strong></p>
<p><strong>寻找因子法</strong></p>
<ul>
<li>时间复杂度： $\Theta(\sqrt{n})$</li>
<li>空间复杂度：$\Theta(1)$</li>
</ul>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">devides?</span> a b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">remainder</span></span> a b) <span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)(<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">is-prime</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">find-devisor</span> n test-devisor)</span><br><span class="line">        (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&gt;</span></span> (<span class="name">square</span> test-devisor) n) n)</span><br><span class="line">            ((<span class="name">devides?</span> n test-devisor) test-devisor)</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">find-devisor</span> n (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> test-devisor)))</span><br><span class="line">        </span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">find-devisor</span> n <span class="number">2</span>) n)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>find- divisor的算法逻辑基于如下事实，如果n不是素数，它必然有一个小于或者等于$\sqrt{n}$的因子。这也意味着该算法只需在和$\sqrt{n}$之间检查因子。由此可知，确定是否素数所需的步数将具有$\Theta(\sqrt{n})$的增长阶。</p>
<p><strong>费马检查</strong></p>
<p>略</p>

        <h3 id="练习-5"   >
          <a href="#练习-5" class="heading-link"><i class="fas fa-link"></i></a>练习</h3>
      <p><strong>1.21</strong></p>
<p>与例题同。略</p>
<p><strong>1.22</strong></p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)(<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">prime?</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">smallest-devisor</span> n)</span><br><span class="line">        (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">find-devisor</span> n test-devisor)</span><br><span class="line">            (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&gt;</span></span> (<span class="name">sqaure</span> test-devisor) n) n)</span><br><span class="line">                  ((<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> (<span class="name"><span class="builtin-name">remainder</span></span> n test-devisor)) test-devisor)</span><br><span class="line">                  (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">find-devisor</span> n (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> test-devisor)))</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        (<span class="name">find-devisor</span> n <span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">smallest-devisor</span> n) n)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">search-for-primes</span> n)</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">report-prime-test</span> elapsed-time)</span><br><span class="line">        (<span class="name"><span class="builtin-name">display</span></span> <span class="string">"***"</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">display</span></span> elapsed-time)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">start-prime-test</span> n start-time)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">prime?</span> n)</span><br><span class="line">            (<span class="name">report-prime-test</span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">runtime</span>) start-time))</span><br><span class="line">            (<span class="name">search-for-primers</span> (<span class="name"><span class="builtin-name">+</span></span> n <span class="number">1</span>))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">timed-prime-test</span> n)</span><br><span class="line">        (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">display</span></span> n)</span><br><span class="line">        (<span class="name">start-prime-test</span> n (<span class="name">runtime</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name">timed-prime-test</span> n)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> try-10000 (<span class="name">search-for-primes</span> <span class="number">10001</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> try-100000 (<span class="name">search-for-primes</span> <span class="number">100001</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> try-1000000 (<span class="name">search-for-primes</span> <span class="number">1000001</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">display</span></span> try-10000)</span><br><span class="line">(<span class="name"><span class="builtin-name">display</span></span> try-100000)</span><br><span class="line">(<span class="name"><span class="builtin-name">display</span></span> try-1000000)</span><br></pre></td></tr></table></div></figure>
<p><strong>1.23</strong><br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)(<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">prime?</span> n)</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">next</span> devisor)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">2</span> devisor)</span><br><span class="line">            <span class="number">3</span></span><br><span class="line">            (<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> devisor)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">smallest-devisor</span> n)</span><br><span class="line">        (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">find-devisor</span> n test-devisor)</span><br><span class="line">            (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">&gt;</span></span> (<span class="name">sqaure</span> test-devisor) n) n)</span><br><span class="line">                  ((<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> (<span class="name"><span class="builtin-name">remainder</span></span> n test-devisor)) test-devisor)</span><br><span class="line">                  (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">find-devisor</span> n (<span class="name">next</span> test-devisor)))</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        (<span class="name">find-devisor</span> n <span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">smallest-devisor</span> n) n)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">search-for-primes</span> n)</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">report-prime-test</span> elapsed-time)</span><br><span class="line">        (<span class="name"><span class="builtin-name">display</span></span> <span class="string">"***"</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">display</span></span> elapsed-time)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">start-prime-test</span> n start-time)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">prime?</span> n)</span><br><span class="line">            (<span class="name">report-prime-test</span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">runtime</span>) start-time))</span><br><span class="line">            (<span class="name">search-for-primers</span> (<span class="name"><span class="builtin-name">+</span></span> n <span class="number">1</span>))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">timed-prime-test</span> n)</span><br><span class="line">        (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">display</span></span> n)</span><br><span class="line">        (<span class="name">start-prime-test</span> n (<span class="name">runtime</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name">timed-prime-test</span> n)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> try-10000 (<span class="name">search-for-primes</span> <span class="number">10001</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> try-100000 (<span class="name">search-for-primes</span> <span class="number">100001</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> try-1000000 (<span class="name">search-for-primes</span> <span class="number">1000001</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">display</span></span> try-10000)</span><br><span class="line">(<span class="name"><span class="builtin-name">display</span></span> try-100000)</span><br><span class="line">(<span class="name"><span class="builtin-name">display</span></span> try-1000000)</span><br></pre></td></tr></table></div></figure><br>注释：这种next取法确实可以减少将近一半的不必要的测试因子。但是总体时间却不会减少一般，因此那不必判断(remainder)的一半的数值却要被拿去判断(= 2 test-devisor)</p>
<p><strong>1.24</strong><br>略</p>
<p><strong>1.25</strong><br>略</p>
<p><strong>1.26</strong><br>略</p>
<p><strong>1.27</strong><br>略</p>
<p><strong>1.28</strong><br>略</p>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h3>
      <p>如果说1.1大节是以scheme语言为例子讲解了计算机程序中的基本语法：</p>
<ul>
<li>计算机程序中表达式与组合式的概念及其求值顺序；</li>
<li>计算机程序中过程（函数）的概念及其求值顺序；</li>
<li>条件分支，谓词判断（比较运算符），逻辑运算符；</li>
<li>过程作为黑箱和隐藏（封装）的概念；</li>
</ul>
<p>那么1.2大节，就是以scheme语言为例，简要介绍了数据结构与算法：</p>
<ul>
<li>线性递归与线性迭代的区别；</li>
<li>求阶乘的线性递归与线性迭代算法；</li>
<li>求斐波那契数列的指数递归与线性递归算法；</li>
<li>$\Theta(f(n))$记号，算法复杂度分析；</li>
<li>求幂($x^n$)的线性递归法与线性迭代法，对数递归法与对数迭代法；</li>
<li>欧几里得算法求最大公约数的对数迭代算法；</li>
<li>判断素数的$\Theta(\sqrt{n})$迭代法；</li>
</ul>
<p>现在我们来用一张表格总结一下本大节中出现过的所有算法：</p>
<div class="table-container">
<div class="table-container"><table>
<thead>
<tr>
<th>需求</th>
<th>阶乘</th>
<th></th>
<th>斐波那契数列</th>
<th></th>
<th>求幂次</th>
<th></th>
<th></th>
<th></th>
<th>最大公约数</th>
<th>素数判断</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法名称</td>
<td>线性递归</td>
<td>线性迭代</td>
<td>指数递归</td>
<td>线性迭代</td>
<td>线性递归</td>
<td>线性迭代</td>
<td>对数递归</td>
<td>对数迭代</td>
<td>对数迭代</td>
<td>1/2次幂迭代</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>$\Theta(n)$</td>
<td>$\Theta(n)$</td>
<td>$\Theta(x^n)$</td>
<td>$\Theta(n)$</td>
<td>$\Theta(n)$</td>
<td>$\Theta(n)$</td>
<td>$\Theta(\log n)$</td>
<td>$\Theta(\log n)$</td>
<td>$\Theta(\log n)$</td>
<td>$\Theta(\sqrt{n})$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$\Theta(n)$</td>
<td>$\Theta(1)$</td>
<td>$\Theta(n)$</td>
<td>$\Theta(1)$</td>
<td>$\Theta(n)$</td>
<td>$\Theta(1)$</td>
<td>$\Theta(\log n)$</td>
<td>$\Theta(1)$</td>
<td>$\Theta(1)$</td>
<td>$\Theta(1)$</td>
</tr>
</tbody>
</table></div>
</div>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/04/28/1-1-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0/">1.1 程序设计的基本元素</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-04-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-04-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="1-1-1-表达式"   >
          <a href="#1-1-1-表达式" class="heading-link"><i class="fas fa-link"></i></a>1.1.1 表达式</h3>
      
        <h3 id="原文摘录"   >
          <a href="#原文摘录" class="heading-link"><i class="fas fa-link"></i></a>原文摘录</h3>
      <p>每一种强有力的语言都必须提供如下三种机制：</p>
<ul>
<li>基本表达式，用于表示语言所关心的最简单的个体</li>
<li>组合的方法，通过它们可以从较简单的东西出发构造出复合的元素</li>
<li>抽象的方法，通过它们可以为复合对象命名，并将它们当作单元去操作</li>
</ul>

        <h3 id="注释"   >
          <a href="#注释" class="heading-link"><i class="fas fa-link"></i></a>注释</h3>
      <p>基本表达式包含两种：<strong>基本数据和基本过程</strong>。3  4 (define a 5)。此时，3 4 a 都是基本的数据。基本的过程则指scheme解释器内置的计算过程（或者函数），比如+ - * /这些运算符，其本质就是一个被解释器预先实现了的过程。</p>
<p>仅有基本的数据与基本的过程显然是不够的，因此还需要将它们用某种方法组合起来，形成一个复合的表达式。比如，(+ (<em> 3 3)(</em> 4 4))就是一个复合表达式（或者称之为组合表达式）。因为此时多个基本数据和基本过程不再相互独立，而是联合了起来，组成了一个可以求值的新的表达式。</p>
<p>当然,<strong>在我们需要将某个组合操作中所蕴涵的计算形式从具体的计算中抽取出来的时候，抽象的方法就开始发挥作用了</strong>。考虑如下情况，假设现在有100个表示直角三角形两直角边长的数对(3,4)(5,6)(7,8)…，需要求其第三边长的平方。诚然，我们可以使用(+ (<em> 3 3)(</em> 4 4))  (+ (<em> 5 5)(</em> 6 6))…去解决问题。但显然，这是种糟糕的解决方案，因为可以看出，每一个求平方和的组合表达式，除了参与计算的具体数字不同之外，其计算中所遵循的规则和步骤是完全一致的！也就是说，每个表达式都具有同样的计算形式！既然如此，那为何不从中提取出这种普遍共通的计算形式以简化计算呢？<br>因此，我们可以定义一种程序类型，将共通的计算形式提取出来存放在这种类型中，这种类型无关乎具体的参与运算的数据，而仅仅表示某一种计算的形式。这样，当要使用具体的数据进行实际的计算时，只需要将数据放入到该程序类型中进行计算就可以了。而这种程序类型我们可以称之为<strong>过程（函数）</strong></p>
<p>比如，我们可以定义一个求平方和的过程<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-square</span> a b)</span><br><span class="line">        (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> a a)(<span class="name"><span class="builtin-name">*</span></span> b b))</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br>于是我们就此完成了一次抽象。在这个意义上，我们可以说，<strong>抽象就是抛开具体的数据，对计算形式进行抽取并且为其命名的行为</strong>。比如，如果要计算数对(3 4)的平方和,只需要执行(sum-square 3 4)的操作就可以了，得到的计算结果将是25。</p>

        <h3 id="补注：关于计算机科学中抽象的概念的再解释"   >
          <a href="#补注：关于计算机科学中抽象的概念的再解释" class="heading-link"><i class="fas fa-link"></i></a>补注：关于计算机科学中抽象的概念的再解释</h3>
      <p>在计算机科学中，抽象具有两个层面的含义：</p>
<ul>
<li>面向计算过程的抽象</li>
<li>面向对象的抽象</li>
</ul>
<p>在计算平方和的例子中，我们看到，参数a b被抽象了，a b在计算过程中可以指代任何具体的数据。因此，此时的抽象是一种<strong>面向计算过程的抽象</strong>。<br>这时候的抽象，其实就是一种将数据一般化的抽象。</p>
<p>但是在抽象的行为中，我们同时也为抽取出来的计算形式进行了命名，使得过程名也可以当作一个基本的单元或者数据或者对象参与到其他运算中去，此时的抽象则是一种<strong>面向对象的抽象</strong>。这时候的抽象，其实就是一种封装性质的抽象。</p>
<p>考虑如下例子：<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)(<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-sqaure</span> ping-fang a b)</span><br><span class="line">        (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">ping-fang</span> a)(<span class="name">ping-fang</span> b))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name">sum-sqaure</span> square <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></div></figure><br>此时，square这个过程是作为一个实际参数被传入到sum-sqaure之中的。在这种情况下，square与a b并无区别，都是作为一个基本的数据参与到了其他的运算之中去了。而至于square过程的内部究竟是如何实现的，编写sum-sqaure过程的程序员并不关心，他只需要知道square过程可以返回某数的平方就可以了。</p>
<p>总结一下，就是：</p>
<ul>
<li>面向过程的抽象，是一种在定义过程时由于将计算形式抽取出来而导致的形式参数一般化而形成的抽象，这种抽象时面向过程内部的。这种抽象的着重带点在于参数的一般化。</li>
<li>面向对象的抽象，是一种将过程整体进行封装后打包，作为一个基本的单位输出到其他运算当中，或者作为其他更大的模块的一个可拆卸的基本组成部分的抽象。这种抽象时面向外部的。这种抽象的着重点在于将过程名视为一种特殊的运算符，以及对过程具体实现的隐藏。</li>
</ul>

        <h3 id="1-1-2-命名和环境"   >
          <a href="#1-1-2-命名和环境" class="heading-link"><i class="fas fa-link"></i></a>1.1.2 命名和环境</h3>
      
        <h3 id="原文摘录-1"   >
          <a href="#原文摘录-1" class="heading-link"><i class="fas fa-link"></i></a>原文摘录</h3>
      <p>程序设计语言中一个必不可少的方面，就是就是它需要提供一种通过名字去使用计算对象的方式。我们将名字标识符称为变量，它的值也就是它所对应的那个变量。</p>
<p>define…允许我们用一个简单的名字去引用一个组合运算的结果。</p>
<p>…我们可以将值与符号相关联，而后又能提取出这些值，这意味着解释器必须维护某种存储能力，以便保持某种名字-值对偶的轨迹。这种存储被称为环境。</p>

        <h3 id="注释-1"   >
          <a href="#注释-1" class="heading-link"><i class="fas fa-link"></i></a>注释</h3>
      <p>这里所说的环境其实就是程序中的命名空间。</p>

        <h3 id="1-1-3-组合式的求值"   >
          <a href="#1-1-3-组合式的求值" class="heading-link"><i class="fas fa-link"></i></a>1.1.3 组合式的求值</h3>
      
        <h3 id="原文摘录-2"   >
          <a href="#原文摘录-2" class="heading-link"><i class="fas fa-link"></i></a>原文摘录</h3>
      <p>要求值一个表达式，做下面的事情：</p>
<ol>
<li>求值该组合式的各个子表达式</li>
<li>将作为最左子表达式的（运算符）的值的过程应用于相应的实际参数，所谓实际参数也就是其他子表达式（运算对象）的值。</li>
</ol>
<p>…为了实现对一个组合式的求值，我们必须先对组合式里的每个元素执行同样的求值过程。因此，在性质上，这一求值过程时递归的…</p>
<p>…反复的运用第一个步骤，总可以把我们带到求值中的某一点，在这里遇到的不是组合式而是基本表达式，例如数，内部运算符或其他名字。处理这些基础情况的方式如下规定：</p>
<ul>
<li>数的值就是它们所表示的数值</li>
<li>内部运算符的值就是能完成相应操作的机器指令序列</li>
<li>其他名字的值就是在环境中关联于这一名字的对象</li>
</ul>
<p>我们可以将第二种规定看作是第三种规定的特殊情况，为此只需将像+和*一类的运算符也包含在全局环境里，并将相应的指令序列作为与之关联的“值”…</p>

        <h3 id="注释-2"   >
          <a href="#注释-2" class="heading-link"><i class="fas fa-link"></i></a>注释</h3>
      <p>刚才我们已经说过，+ - *  /之类的内部运算符，本质上其实是一个个的过程，而这里又说，内部运算符的值就是能完成相应操作的机器指令序列。由此可见，过程在解释器中的本质其实就是一段段的机器指令，而过程名则是在环境中被关联到这些机器指令的变量或者标识符。</p>

        <h3 id="1-1-4-复合过程"   >
          <a href="#1-1-4-复合过程" class="heading-link"><i class="fas fa-link"></i></a>1.1.4 复合过程</h3>
      
        <h3 id="原文摘录-3"   >
          <a href="#原文摘录-3" class="heading-link"><i class="fas fa-link"></i></a>原文摘录</h3>
      <figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)(<span class="name"><span class="builtin-name">*</span></span> x x))</span><br></pre></td></tr></table></div></figure>
<p>这样，我们就有了一个复合过程，给它取的名字是square…求值这一定义的结果是创建起一个复合过程，并将它关联于名字square。</p>

        <h3 id="注释-3"   >
          <a href="#注释-3" class="heading-link"><i class="fas fa-link"></i></a>注释</h3>
      <p>创建一个复合过程的本质就是生成一段机器指令，并将该指令在环境中关联于相应的名字。这里所说的复合过程，是相对于前面所说的基本过程而言的，基本过程就是解释器内部预置的过程，复合过程就是用户自定义的过程。本质上其实没有任何区别。</p>

        <h3 id="1-1-5-过程应用的代换模型（过程的求值步骤）"   >
          <a href="#1-1-5-过程应用的代换模型（过程的求值步骤）" class="heading-link"><i class="fas fa-link"></i></a>1.1.5 过程应用的代换模型（过程的求值步骤）</h3>
      
        <h3 id="原文摘录-4"   >
          <a href="#原文摘录-4" class="heading-link"><i class="fas fa-link"></i></a>原文摘录</h3>
      <p>对于复合过程，过程应用的计算过程是：</p>
<ul>
<li>将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程体求值</li>
</ul>
<p>…这种计算过程称为过程应用的代换模型</p>
<p><strong>应用序和正则序</strong></p>

        <h3 id="原文摘录-5"   >
          <a href="#原文摘录-5" class="heading-link"><i class="fas fa-link"></i></a>原文摘录</h3>
      <p>按照1.1.3节给出有关求值的描述，解释器首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数。</p>
<p>…另一种求值模型是先不求出运算对象的值，直到实际需要它们的值时再去做。采用这种求值方式，我们就应该首先用运算对象表达式去代换形式参数，直到得到一个只包含基本运算符的表达式，然后再去执行求值。</p>
<p>这种<strong>完全展开而后归约</strong>的求值模型称为正则序求值，与之对应的时现在解释器里实际使用的<strong>先求值参数而后应用</strong>的方式，它称为应用序求值。</p>

        <h3 id="注释-4"   >
          <a href="#注释-4" class="heading-link"><i class="fas fa-link"></i></a>注释</h3>
      <p>例：以(f 5)为例，用两种模型求值，考察其中的不同之处<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-of-square</span> a b) </span><br><span class="line">        (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">square</span> a)(<span class="name">square</span> b))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> a)</span><br><span class="line">    (<span class="name">sum-of-square</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> a)(<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> a))</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br><strong>应用序求值步骤</strong>：<br>(f a)  ——&gt;</p>
<p>(sum-of-square (+ 1 a)(* 2 a))   ——&gt; //对运算符f进行求值，即取出过程体</p>
<p>(sum-of-square (+ 1 5)(* 2 5))  ——&gt; //用实际参数替换形式参数a</p>
<p> (sum-of-square 6 10)——&gt; //对运算对象进行求值计算，<strong>这是应用序区别于正则序的关键</strong></p>
<p>(+ (sqaure 6)(sqaure 10)) ——&gt; //对运算符sum-of-square进行求值</p>
<p>(+ (<em> 6 6)(</em> 10 10)) ——&gt; //对运算符square进行求值</p>
<p>(+ 36 100) ——&gt; //进行最终的计算</p>
<p>136</p>
<p><strong>正则序求值步骤</strong></p>
<p>(f a)  ——&gt;</p>
<p>(sum-of-square (+ 1 a)(* 2 a))   ——&gt; //对运算符f进行求值，即取出过程体</p>
<p>(sum-of-square (+ 1 5)(<em> 2 5))  ——&gt; //用实际参数替换形式参数a<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">+</span></span> </span><br><span class="line">    (<span class="name">square</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">5</span>))    </span><br><span class="line">    (<span class="name">square</span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">5</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br>——&gt; //不对运算对象进行求值，继续对sum-of-square进行求值展开。<em>*这是正则序区别于应用序的关键</em></em></p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">+</span></span></span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">5</span>)(<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">5</span>))</span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">5</span>)(<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">5</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>——&gt; //仍然不对运算对象求值，继续展开square。<strong>此时已经归约到最简状态，即，已经没有可以继续展开的运算符（也就是过程名了）</strong>。</p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">+</span></span></span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> <span class="number">6</span> <span class="number">6</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">*</span></span> <span class="number">10</span> <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>——&gt; // 开始具体求值</p>
<p>(+ 36 100) ——&gt;</p>
<p>136</p>
<p>总结一下，就是：</p>
<ul>
<li>正则序和应用序都需要对运算符也就是对过程名进行求值展开</li>
<li>正则序和应用序都需要用实际参数替换过程体中的形式参数</li>
<li>正则序不会对实际参数取代形式参数之后的运算对象表达式进行求值，而是<strong>保留其组合表达式的形式</strong>，进而继续对下一个过程名进行求值展开，直到所有嵌套的过程名被全部展开完毕，整个过程被归约为一个只由基本运算符和数值组成的组合表达式为止。然后对这个表达式进行求值。</li>
<li>应用序会对实际参数取代形式参数之后的运算对象表达式进行求值，当所有的运算对象表达式求值完毕后，再继续对下一个过程名进行求值展开，直到所有嵌套的过程名被全部展开完毕。<strong>在整个过程的求值过程中，该模型的运算对象始终是一个数值而非组合表达式</strong></li>
</ul>

        <h3 id="1-1-6-条件表达式和谓词"   >
          <a href="#1-1-6-条件表达式和谓词" class="heading-link"><i class="fas fa-link"></i></a>1.1.6 条件表达式和谓词</h3>
      
        <h3 id="本节概要"   >
          <a href="#本节概要" class="heading-link"><i class="fas fa-link"></i></a>本节概要</h3>
      <p>如果想要用语言表述一个数的绝对值|x|，那么就需要用到条件表达式cond/if和谓词。<br>可以这样子写：</p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">abs</span></span> x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        ((<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>) (<span class="name">-x</span>))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> X <span class="number">0</span>) <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> x)</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>所以cond就像其他语言中的if-else if-else。</p>
<p>当然，也可以用双分支if实现。当x&lt;=0,那么就返回-x，否则返回x本身。</p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">abs</span></span> x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;=</span></span> x <span class="number">0</span>)</span><br><span class="line">        (<span class="name">-x</span>)</span><br><span class="line">        x</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>除了基本算术运算符+ - <em> /，基本比较运算符（即谓词运算符）&lt; &gt; &gt;= &lt;=之外（注意，scheme中没有!=,如果你想使用!=,需要这样做 <em>*(not (= 3 4))</em></em> ），还有复合运算符and，or,not。</p>
<p>借助复合运算符，我们可以重定义解释器内部的&lt;=运算符：<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">&lt;=</span></span> x y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">=</span></span> x y)</span><br><span class="line">        (<span class="name"><span class="builtin-name">&lt;</span></span> x y)</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure></p>

        <h3 id="练习"   >
          <a href="#练习" class="heading-link"><i class="fas fa-link"></i></a>练习</h3>
      <p><strong>1.1</strong></p>
<p>略</p>
<p><strong>1.2</strong></p>
<p>略</p>
<p><strong>1.3</strong></p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">max-sum</span> a b c)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> a b)(<span class="name"><span class="builtin-name">&gt;=</span></span> b c))(<span class="name"><span class="builtin-name">+</span></span> a b))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> a c)(<span class="name"><span class="builtin-name">&gt;=</span></span> c b))(<span class="name"><span class="builtin-name">+</span></span> a c))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> b a)(<span class="name"><span class="builtin-name">&gt;=</span></span> a c))(<span class="name"><span class="builtin-name">+</span></span> b a))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> b c)(<span class="name"><span class="builtin-name">&gt;=</span></span> c a))(<span class="name"><span class="builtin-name">+</span></span> b c))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">&gt;=</span></span> c a)(<span class="name"><span class="builtin-name">&gt;=</span></span> a b))(<span class="name"><span class="builtin-name">+</span></span> c a))</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name"><span class="builtin-name">+</span></span> c b))</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p><strong>1.4</strong><br>略</p>
<p><strong>1.5</strong></p>
<p>如果采用应用序求值，会导致程序陷入无限循环，采用正则序则返回0</p>

        <h3 id="1-1-7-采用牛顿法求平方根"   >
          <a href="#1-1-7-采用牛顿法求平方根" class="heading-link"><i class="fas fa-link"></i></a>1.1.7 采用牛顿法求平方根</h3>
      
        <h3 id="原文摘录-6"   >
          <a href="#原文摘录-6" class="heading-link"><i class="fas fa-link"></i></a>原文摘录</h3>
      <p>计算机如何求出平方根呢？最常用的就是牛顿的逐步逼近方法。这一方法告诉我们：如果对x的平方根的值有了一个猜测y,那么就可以通过执行一个简单操作去得到更好的猜测：只需要y和x/y的平均值（它更接近实际的平方根值）</p>

        <h3 id="注释-5"   >
          <a href="#注释-5" class="heading-link"><i class="fas fa-link"></i></a>注释</h3>
      <p>…我们可以将这一基本策略写成下面的过程:</p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 主函数</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sqrt-iter</span> guess x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">        guess</span><br><span class="line">        (<span class="name">sqrt-iter</span> (<span class="name">improve</span> guess x) x)</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 若不够精确，则取出下一个猜测值</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve</span> guess x)</span><br><span class="line">    (<span class="name">average</span> (<span class="name"><span class="builtin-name">/</span></span> x guess) guess)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average</span> x y)(<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> x y) <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"># 判断是否达到精度：看猜测值的平方与x的差的绝对值是否小于0.001</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> </span><br><span class="line">        (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> x (<span class="name">square</span> guess))) </span><br><span class="line">        <span class="number">0.001</span></span><br><span class="line">    )   </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)(<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">abs</span></span> x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">-</span></span> x)</span><br><span class="line">        x</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>当然，有结构更加优雅的版本：由于good-enough?和improve过程都是主函数的具有特定功能的辅助函数，而不是普遍适用的通用工具类函数。因此可以将它们的定义放在主函数体内。而abs,sqaure,average都是工具类函数，因此定义可以放在主函数外部，以便其他函数也可以对其进行调用。<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)(<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">abs</span></span> x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">-</span></span> x)</span><br><span class="line">        x</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average</span> x y)(<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> x y) <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sqrt-iter</span> guess x)</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve</span> guess x)</span><br><span class="line">        (<span class="name">average</span> (<span class="name"><span class="builtin-name">/</span></span> x guess) guess)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">        (<span class="name"><span class="builtin-name">&lt;</span></span> </span><br><span class="line">            (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> x (<span class="name">square</span> guess))) </span><br><span class="line">            <span class="number">0.001</span></span><br><span class="line">        )   </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">        guess</span><br><span class="line">        (<span class="name">sqrt-iter</span> (<span class="name">improve</span> guess x) x)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br>最后，还可以继续进行改进：既然两个辅助函数被定义在了主函数内部，那么主函数的形式参数x和guess必定是对两个辅助函数也是适用的，既然如此，那就没必要再对辅助函数显式地设置形式参数了。<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)(<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">abs</span></span> x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">-</span></span> x)</span><br><span class="line">        x</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average</span> x y)(<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> x y) <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sqrt-iter</span> guess x)</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve</span>)</span><br><span class="line">        (<span class="name">average</span> (<span class="name"><span class="builtin-name">/</span></span> x guess) guess)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">&lt;</span></span> </span><br><span class="line">            (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> x (<span class="name">square</span> guess))) </span><br><span class="line">            <span class="number">0.001</span></span><br><span class="line">        )   </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough?</span>)</span><br><span class="line">        guess</span><br><span class="line">        (<span class="name">sqrt-iter</span> (<span class="name">improve</span>) x)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></div></figure><br>最后，我们还需要为sqrt-iter过程套上一层外衣，这是因为sqrt-iter需要指定两个参数，一个是用户初次猜测的值，一个是需要求平方根的值。如果将这个过程交给用户使用，那么这将是不符合大部分人的使用习惯的，因此，需要套上一层sqrt的过程作为对外封装的外衣：<br><figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)(<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">abs</span></span> x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">-</span></span> x)</span><br><span class="line">        x</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average</span> x y)(<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> x y) <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">sqrt</span></span> x)</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sqrt-iter</span> guess)</span><br><span class="line"></span><br><span class="line">        (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve</span>)</span><br><span class="line">            (<span class="name">average</span> (<span class="name"><span class="builtin-name">/</span></span> x guess) guess)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span>)</span><br><span class="line">            (<span class="name"><span class="builtin-name">&lt;</span></span> </span><br><span class="line">                (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> x (<span class="name">square</span> guess))) </span><br><span class="line">                <span class="number">0.001</span></span><br><span class="line">            )   </span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough?</span>)</span><br><span class="line">            guess</span><br><span class="line">            (<span class="name">sqrt-iter</span> (<span class="name">improve</span>) x)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">   </span><br><span class="line">    (<span class="name">sqrt-iter</span> <span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">sqrt</span></span> <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">97/56</span></span><br></pre></td></tr></table></div></figure></p>

        <h3 id="练习-1"   >
          <a href="#练习-1" class="heading-link"><i class="fas fa-link"></i></a>练习</h3>
      <p><strong>练习1.6</strong></p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average</span> x y)</span><br><span class="line">	(<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> x y) <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">abs</span></span> x)</span><br><span class="line">	(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">		(<span class="name"><span class="builtin-name">-</span></span> x)</span><br><span class="line">		x</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)</span><br><span class="line">	(<span class="name"><span class="builtin-name">*</span></span> x x)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter-sqrt</span> guess x)</span><br><span class="line"></span><br><span class="line">	(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">		</span><br><span class="line">		(<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> x (<span class="name">square</span> guess))) <span class="number">0.001</span>)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve-guess</span> guess x)</span><br><span class="line">		(<span class="name">average</span> guess (<span class="name"><span class="builtin-name">/</span></span> x guess))</span><br><span class="line">	)</span><br><span class="line">	</span><br><span class="line">	(<span class="name">new-if</span> (<span class="name">good-enough?</span> guess x) </span><br><span class="line">		guess</span><br><span class="line">		(<span class="name">iter-sqrt</span> (<span class="name">improve-guess</span> guess x) x)</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">sqrt</span></span> x)</span><br><span class="line">	(<span class="name">iter-sqrt</span> <span class="number">1</span> x)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">new-if</span> predicate then-caluse else-caluse)</span><br><span class="line">	(<span class="name"><span class="builtin-name">cond</span></span> (<span class="name">predicate</span> then-caluse)</span><br><span class="line">	 (<span class="name"><span class="builtin-name">else</span></span> else-caluse)</span><br><span class="line">	)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p>这个问题的本质与练习1.5相同。scheme的解释器的求值模式为<br>应用序求值。在使用new-if进行计算时，schene首先会计算出三个形式参数<br>被实际参数取代后的值，然后才能进行下一步的cond计算，但这时的第三个参数sqrt-iter在求值时会无限调用自身，因此导致程序陷入死循环。</p>
<p><strong>练习1.7</strong></p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average</span> x y)</span><br><span class="line">	(<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> x y) <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">abs</span></span> x)</span><br><span class="line">	(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">		(<span class="name"><span class="builtin-name">-</span></span> x)</span><br><span class="line">		x</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x)</span><br><span class="line">	(<span class="name"><span class="builtin-name">*</span></span> x x)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter-sqrt</span> guess x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> guess x)</span><br><span class="line">		</span><br><span class="line">		(<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> guess (<span class="name">improve-guess</span> guess x))) guess) <span class="number">0.001</span>) </span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve-guess</span> guess x)</span><br><span class="line">		(<span class="name">average</span> guess (<span class="name"><span class="builtin-name">/</span></span> x guess))</span><br><span class="line">	)</span><br><span class="line">	</span><br><span class="line">	(<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough?</span> guess x) </span><br><span class="line">		guess</span><br><span class="line">		(<span class="name">iter-sqrt</span> (<span class="name">improve-guess</span> guess x) x)</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">sqrt</span></span> x)</span><br><span class="line">	(<span class="name">iter-sqrt</span> <span class="number">1</span> x)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>
<p><strong>练习1.8</strong></p>
<figure class="highlight scheme"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube-root</span> x)</span><br><span class="line">	</span><br><span class="line">	(<span class="name">cube-root-iter</span> x <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube-root-iter</span> x guess)</span><br><span class="line">	</span><br><span class="line">	(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">imporve-guess</span> x guess)</span><br><span class="line">		(<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">/</span></span> x (<span class="name"><span class="builtin-name">*</span></span> guess guess)) (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> guess)) <span class="number">3</span>)</span><br><span class="line">	)</span><br><span class="line">	</span><br><span class="line">	(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> x guess)</span><br><span class="line">		(<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> x (<span class="name">cube</span> guess))) <span class="number">0.001</span>)</span><br><span class="line">	)</span><br><span class="line">	</span><br><span class="line">	(<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough?</span> x guess)</span><br><span class="line">		guess</span><br><span class="line">		(<span class="name">cube-root-iter</span> x (<span class="name">imporve-guess</span> x guess))</span><br><span class="line">	)</span><br><span class="line">		</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cube</span> x)</span><br><span class="line">	(<span class="name"><span class="builtin-name">*</span></span> x x x)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">abs</span></span> x)</span><br><span class="line">	(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> x <span class="number">0</span>)</span><br><span class="line">		(<span class="name"><span class="builtin-name">-</span></span> x)</span><br><span class="line">		x</span><br><span class="line">	)</span><br><span class="line">)</span><br></pre></td></tr></table></div></figure>

        <h3 id="1-1-8-过程作为黑箱抽象"   >
          <a href="#1-1-8-过程作为黑箱抽象" class="heading-link"><i class="fas fa-link"></i></a>1.1.8 过程作为黑箱抽象</h3>
      
        <h3 id="原文摘录-7"   >
          <a href="#原文摘录-7" class="heading-link"><i class="fas fa-link"></i></a>原文摘录</h3>
      <p>…如果只看good-enough?过程，与其说square是一个过程，不如说它是一个过程的抽象，即所谓的过程抽象。在这一抽象层次上，任何能计算出平方的过程都同样可用。</p>
<p>由此可见，一个过程定义应该能隐藏起一些细节。这将使过程的使用者可能不必自己去写这些过程，而是从其他程序员那里作为一个黑箱接受了它。用户在使用一个过程时，应该不需要去弄清它是如何实现的。</p>
<p><strong>局部名</strong></p>
<p>…过程的形式参数名必须局部于有关的过程体</p>
<p>…一个过程的定义约束了它所有的形式参数。如果在一个完整的过程定义里将某个约束变量统一换名，这一过程定义的意义将不会有任何改变。如果一个变量不是被约束的，我们就称它为自由的。一个名字的定义被约束于的那一集表达式被称为这个名字的作用域。<strong>在一个过程定义里，被声明为这个过程的形式参数的那些约束变量，就以这个过程的体作为它们的作用域</strong></p>
<p>在上面的good-enough?定义中,guess和x时约束变量，而&lt;,-,abs和square则是自由的。</p>
<p><strong>内部定义与块结构</strong></p>
<p>…过程的形式参数时相应过程体里的局部名字</p>
<p>…我们也希望将这种子过程局部化，将它们隐藏到sqrt里面，以使sqrt可以与其他采用逼近的过程共存，让它们中的每一个都有good-enough?过程。…我们要允许一个过程里带有一些内部定义，使他们是局部于这一过程的。</p>

        <h3 id="1-1-总结"   >
          <a href="#1-1-总结" class="heading-link"><i class="fas fa-link"></i></a>1.1 总结</h3>
      <ul>
<li>1.1.1 什么是基本表达式和组合表达式</li>
<li>1.1.2 什么是命名和环境</li>
<li>1.1.3 组合表达式如何进行求值</li>
<li>1.1.4 如何定义一个过程</li>
<li>1.1.5 过程被调用时，它时如何求值的</li>
<li>1.1.6 比较运算符（&gt; &lt; = &gt;= &lt;=）,逻辑运算符（and or not），分支判断（cond…else,if）</li>
<li>1.1.7 以求平方根为例，实现上述知识点</li>
<li>1.1.8 讲述过程作为黑箱，形参作为过程体内的局部变量，以及过程的内部定义和块结构</li>
</ul>
<p>总体来说，这一节<strong>介绍了scheme的基本语法</strong>以及<strong>过程作为黑箱以及过程的内部定义</strong>的编程思想。</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/sakura.svg" alt="avatar"></div><p class="sidebar-ov-author__text">I am Samson</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/SamsonRuan" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://segmentfault.com/" target="_blank" rel="noopener" data-popover="思否" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">sf</span></a><a class="sidebar-ov-social-item" href="https://csdn.com" target="_blank" rel="noopener" data-popover="CSDN" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">CSDN</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">2</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">1</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">6</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Samson Yuen</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v4.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0-rc.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script type="text/x-mathjax-config">var mathjaxMhchem = '';
var mathJaxTex = {
  equationNumbers: {
    autoNumber: 'AMS'
  }
};

if (true) {
  mathjaxMhchem = 'https://cdn.jsdelivr.net/npm/mathjax-mhchem@3.3.2/mhchem.min.js';
  MathJax.Ajax.config.path['mhchem'] = mathjaxMhchem;

  mathJaxTex.extensions = [mathjaxMhchem];
} else {
  mathJaxTex.extensions = ['AMSmath.js','AMSsymbols.js'];
}

MathJax.Hub.Config({
  menuSettings: {
    zoom: 'None'
  },
  showMathMenu: false,
  jax: ['input/TeX','output/CommonHTML'],
  extensions: ['tex2jax.js'],
  TeX: mathJaxTex,
  tex2jax: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['\\[', '\\]']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});

MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
  MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
    if (data.display) {
      var next = data.script.nextSibling;
      while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling; }
      if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next); }
    }
  });
});

MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i = 0; i < all.length; i++) {
    document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
  }
});
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/utils.js?v=2.0.0-rc.0"></script><script src="/js/stun-boot.js?v=2.0.0-rc.0"></script><script src="/js/scroll.js?v=2.0.0-rc.0"></script><script src="/js/header.js?v=2.0.0-rc.0"></script><script src="/js/sidebar.js?v=2.0.0-rc.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>